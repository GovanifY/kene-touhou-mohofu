
/*---------------------------------------------------------
	東方模倣風 〜 Toho Imitation Style.
	http://mohou.huuryuu.com/
	-------------------------------------------------------
	PSPL - PSP customised SDL Layer port.
	SDL Copyright (C) 1997-2004 Sam Lantinga.
---------------------------------------------------------*/

#ifdef SAVE_RCSID
static char rcsid =
 "@(#) $Id: PSPL_mixer.c, v 1.10 2004/01/04 16:49:11 slouken Exp $";
#endif

//#include <psp_types.h>
/* This provides the default mixing callback for the SDL audio routines */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "./../include/PSPL_audio.h"
#include "./../include/PSPL_mutex.h"
#include "./../include/PSPL_timer.h"

#ifdef NOT_PSP
	//#include "PSPL_cp uinfo.h"
#endif /*NOT_PSP*/

#include "PSPL_sysaudio.h"

#ifdef NOT_PSP
	//#include "PSPL_cp uinfo.h"
	#include "PSPL_mixer_MMX.h"
	#include "PSPL_mixer_MMX_VC.h"
	#include "PSPL_mixer_m68k.h"
#endif /*NOT_PSP*/

/* psp専用の命令(pspのcpuにしか無いアセンブラ命令)を活用する。(組み込み関数) */
#ifndef psp_min
	#define psp_min __builtin_allegrex_min
#endif
#ifndef psp_max
	#define psp_max __builtin_allegrex_max
#endif


#ifndef SDL_SetError_bbb
	#define SDL_SetError_bbb( ... )
#endif

/* This table is used to add two sound values together and pin
 * the value to avoid overflow.  (used with permission from ARDI)
 * Changed to use 0xFE instead of 0xff for better sound quality.
 */
#if 0
static const u8 mix8[0x200] =
{
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x00x : 0(min) */
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x01x : 0(min) */
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x02x : 0(min) */
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x03x : 0(min) */
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x04x : 0(min) */
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x05x : 0(min) */
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x06x : 0(min) */
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x07x : 0(min) */
 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, /* 0x08x : 0x00 ... 0x0f */
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, /* 0x09x : 0x10 ... 0x1f */
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, /* 0x0ax : 0x20 ... 0x2f */
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, /* 0x0bx : 0x30 ... 0x3f */
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, /* 0x0cx : 0x40 ... 0x4f */
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, /* 0x0dx : 0x50 ... 0x5f */
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, /* 0x0ex : 0x60 ... 0x6f */
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, /* 0x0fx : 0x70 ... 0x7f */
//
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, /* 0x10x : 0x80 ... 0x8f */
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, /* 0x11x : 0x90 ... 0x9f */
 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, /* 0x12x : 0xa0 ... 0xaf */
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, /* 0x13x : 0xb0 ... 0xbf */
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, /* 0x14x : 0xc0 ... 0xcf */
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, /* 0x15x : 0xd0 ... 0xdf */
 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, /* 0x16x : 0xe0 ... 0xef */
 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xfe, /* 0x17x : 0xf0 ... 0xff(but, max:0xfe) */
 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, /* 0x08x : 0xfe(max) */
 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, /* 0x09x : 0xfe(max) */
 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, /* 0x0ax : 0xfe(max) */
 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, /* 0x0bx : 0xfe(max) */
 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, /* 0x0cx : 0xfe(max) */
 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, /* 0x0dx : 0xfe(max) */
 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, /* 0x0ex : 0xfe(max) */
 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe  /* 0x0fx : 0xfe(max) */
};
#endif
/* The volume ranges from 0 - 128 */
#define ADJUST_VOLUME(s, v) 	(s = (s*v)/SDL_MIX_MAXVOLUME)
#define ADJUST_VOLUME_U8(s, v)	(s = (((s-128)*v)/SDL_MIX_MAXVOLUME)+128)

void PSPL_MixAudio(u8 *dst, const u8 *src, u32 len, int volume)
{
	u16 format;
	if ( volume == 0 )
	{
		return;
	}
	/* Mix the user-level audio format */
	if ( current_audio )
	{
		if ( current_audio->convert.needed )
				{	format = current_audio->convert.src_format;		}
		else	{	format = current_audio->spec.format;			}
	}
	else
	{
		/* HACK HACK HACK */
		format = AUDIO_S16;
	}
	switch (format)
	{
	case AUDIO_U8:
		{
			#if defined(__M68000__) && defined(__GNUC__)
			PSPL_MixAudio_m68k_U8((char*)dst, (char*)src, (unsigned long)len, (long)volume, (char *)mix8);
			#else
			while ( len-- )
			{
				u8 src_sample;
				src_sample = *src;
				ADJUST_VOLUME_U8(src_sample, volume);
//				*dst = mix8[(*dst)+(src_sample)];
				{
					u32 i;
					i = (*dst)+(src_sample);
					i >>= 1;
					i = psp_min(i, 0xfe);
					*dst = (u8)i;
				}
				dst++;
				src++;
			}
			#endif
		}
		break;
	case AUDIO_S8:
		{
			#if defined(i386) && defined(__GNUC__) && defined(USE_ASMBLIT)
			if (SDL_HasM MX())
			{
				PSPL_MixAudio_MMX_S8((char*)dst, (char*)src, (unsigned int)len, (int)volume);
			}
			else
			#endif
			#if defined(USE_ASM_MIXER_VC)
			if (SDL_HasM MX())
			{
				PSPL_MixAudio_MMX_S8_VC((char*)dst, (char*)src, (unsigned int)len, (int)volume);
			}
			else
			#endif
			#if defined(__M68000__) && defined(__GNUC__)
			PSPL_MixAudio_m68k_S8((char*)dst, (char*)src, (unsigned long)len, (long)volume);
			#else
			{
				s8 *dst8;
				s8 *src8;
				s8 src_sample;
				int dst_sample;
				src8 = (s8 *)src;
				dst8 = (s8 *)dst;
				while ( len-- )
				{
					src_sample = *src8;
					ADJUST_VOLUME(src_sample, volume);
					dst_sample = *dst8 + src_sample;
					const int MAX_AUDIOVAL_S8 = ((1<<(8-1))-1);
					const int MIN_AUDIOVAL_S8 = -(1<<(8-1));
					#if (0)
							if ( dst_sample > MAX_AUDIOVAL_S8 ) 	{	*dst8 = MAX_AUDIOVAL_S8;	}
					else	if ( dst_sample < MIN_AUDIOVAL_S8 ) 	{	*dst8 = MIN_AUDIOVAL_S8;	}
					else
					#else
					/*(psp専用)*/
				/*	if (0<dst_sample)	*/	{	dst_sample = psp_min(dst_sample, MAX_AUDIOVAL_S8);	}
				/*	else				*/	{	dst_sample = psp_max(dst_sample, MIN_AUDIOVAL_S8);	}
					#endif
					{
						*dst8 = dst_sample;
					}
					dst8++;
					src8++;
				}
			}
			#endif
		}
		break;
	case AUDIO_S16LSB:
		{
			#if defined(i386) && defined(__GNUC__) && defined(USE_ASMBLIT)
			if (SDL_HasM MX())
			{
				PSPL_MixAudio_MMX_S16((char*)dst, (char*)src, (unsigned int)len, (int)volume);
			}
			else
			#elif defined(USE_ASM_MIXER_VC)
			if (SDL_HasM MX())
			{
				PSPL_MixAudio_MMX_S16_VC((char*)dst, (char*)src, (unsigned int)len, (int)volume);
			}
			else
			#endif
			#if defined(__M68000__) && defined(__GNUC__)
			PSPL_MixAudio_m68k_S16LSB((short*)dst, (short*)src, (unsigned long)len, (long)volume);
			#else
			{
			//	len >>= 1;//	len /= 2;
				while ( len-=2 )
				{
					s16 src1;
					s16 src2;
					src1 = (((src[1])<<8)|(src[0]));
					ADJUST_VOLUME(src1, volume);
					src2 = (((dst[1])<<8)|(dst[0]));
					src += 2;
					int dst_sample;
					dst_sample = src1 + src2;
					const int MAX_AUDIOVAL_S16LSB = ((1<<(16-1))-1);
					const int MIN_AUDIOVAL_S16LSB = -(1<<(16-1));
					#if (0)
							if ( dst_sample > MAX_AUDIOVAL_S16LSB ) 	{	dst_sample = MAX_AUDIOVAL_S16LSB;	}
					else	if ( dst_sample < MIN_AUDIOVAL_S16LSB ) 	{	dst_sample = MIN_AUDIOVAL_S16LSB;	}
					#else
					/*(psp専用)*/
				/*	if (0<dst_sample)	*/	{	dst_sample = psp_min(dst_sample, MAX_AUDIOVAL_S16LSB);	}
				/*	else				*/	{	dst_sample = psp_max(dst_sample, MIN_AUDIOVAL_S16LSB);	}
					#endif
					dst[0] = (dst_sample&0xff);
					dst_sample >>= 8;
					dst[1] = (dst_sample&0xff);
					dst += 2;
				}
			}
			#endif
		}
		break;
	case AUDIO_S16MSB:
		{
			#if defined(__M68000__) && defined(__GNUC__)
			PSPL_MixAudio_m68k_S16MSB((short*)dst, (short*)src, (unsigned long)len, (long)volume);
			#else
			{
			//	len >>= 1;//	len /= 2;
				while ( len-=2 )
				{
					s16 src1;
					s16 src2;
					src1 = (((src[0])<<8)|(src[1]));
					ADJUST_VOLUME(src1, volume);
					src2 = (((dst[0])<<8)|(dst[1]));
					src += 2;
					int dst_sample;
					dst_sample = src1 + src2;
					const int MAX_AUDIOVAL_S16MSB = ((1<<(16-1))-1);
					const int MIN_AUDIOVAL_S16MSB = -(1<<(16-1));
					#if (0)
							if ( dst_sample > MAX_AUDIOVAL_S16MSB ) 	{	dst_sample = MAX_AUDIOVAL_S16MSB;	}
					else	if ( dst_sample < MIN_AUDIOVAL_S16MSB ) 	{	dst_sample = MIN_AUDIOVAL_S16MSB;	}
					#else
					/*(psp専用)*/
				/*	if (0<dst_sample)	*/	{	dst_sample = psp_min(dst_sample, MAX_AUDIOVAL_S16MSB);	}
				/*	else				*/	{	dst_sample = psp_max(dst_sample, MIN_AUDIOVAL_S16MSB);	}
					#endif
					dst[1] = (dst_sample&0xff);
					dst_sample >>= 8;
					dst[0] = (dst_sample&0xff);
					dst += 2;
				}
			}
			#endif
		}
		break;
	default: /* If this happens... FIXME! */
		SDL_SetError_bbb("PSPL_MixAudio(): unknown audio format");
		return;
	}
}
